<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Runtime Debugging</title><link rel="stylesheet" href="taoup.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.58.1"/><link rel="home" href="index.html" title="The Art of Unix Programming"/><link rel="up" href="toolschapter.html" title="Chapter 15. Tools"/><link rel="previous" href="ch15s05.html" title="Version-Control Systems"/><link rel="next" href="ch15s07.html" title="Profiling"/></head><body><mbp:pagebreak /><div class="sect1" lang="en"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="id2989177"/>Runtime Debugging</h2></div></div><p>Anyone who has been programming longer than a week knows that
getting the syntax of your programming language right is the
<span class="emphasis"><em>easy</em></span> part of debugging. The hard part comes after that,
when you need to understand why your syntactically correct program
doesn't behave as you expect.</p><p>The Unix tradition encourages developers to anticipate this
problem by designing for transparency &#8212; in particular, designing
programs in such a way that their internal data flows are readily
monitored with the naked eye and simple tools, and readily mentally
modeled<a id="id2989204" class="indexterm"/>. This is a topic we covered in detail in
<a href="transparencychapter.html" title="Chapter 6. Transparency">Chapter 6</a>.  Design for
transparency is valuable both for preventing bugs and for easing the
runtime-debugging task.</p><p>Design for transparency is not, however, sufficient in itself.
When you are debugging a program at runtime, it's extremely useful to
be able to examine the state of your program at runtime, set
breakpoints, and execute pieces of it down to the single-statement
level in a controlled way. Unix has a long tradition of hosting
programs to help you with this. Open-source Unixes feature a powerful
one called <i>gdb</i> (yet another
FSF<a id="id2989245" class="indexterm"/>
project) that supports C<a id="id2989254" class="indexterm"/> and C++<a id="id2989262" class="indexterm"/> debugging.</p><p>Perl<a id="id2989275" class="indexterm"/>,
Python<a id="id2989283" class="indexterm"/>,
Java<a id="id2989292" class="indexterm"/>, and Emacs
Lisp<a id="id2989300" class="indexterm"/> all
support standard packages or programs (included with their base
distributions) that allow you to set breakpoints, control execution,
and do general runtime-debugger things. Tcl<a id="id2989312" class="indexterm"/>, designed as a small language for small
projects, has no such facility (though it does have a trace facility
that can be used to watch variables at runtime).</p><p>Remember the Unix philosophy. Spend your time on design quality, not
the low-level details, and automate away everything you can &#8212;
including the detail work of runtime debugging.</p></div></body></html>
