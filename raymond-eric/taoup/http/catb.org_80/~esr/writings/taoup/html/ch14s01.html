<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unix's Cornucopia of Languages</title><meta name="generator" content="DocBook XSL Stylesheets V1.58.1"/><link rel="home" href="index.html" title="The Art of Unix Programming"/><link rel="up" href="languageschapter.html" title="Chapter 14. Languages"/><link rel="previous" href="languageschapter.html" title="Chapter 14. Languages"/><link rel="next" href="why_not_c.html" title="Why Not C?"/></head><body><mbp:pagebreak /><div class="sect1" lang="en"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="id2970785"/>Unix's Cornucopia of Languages</h2></div></div><p>Unix supports a wider variety of application languages than does
any other single operating system; indeed, it may well have hosted
more different languages than every other operating system in the
history of computing combined.<sup>[<a id="id2970798" href="#ftn.id2970798">122</a>]</sup></p><p>There are at least two excellent reasons for this huge
diversity. One is the wide use of Unix as a research and teaching
platform. The other (far more relevant for working programmers) is the
fact that matching your application design with the proper
implementation language(s) can make an immense difference in your
productivity. Therefore the Unix tradition encourages the design of
domain-specific languages (as we mentioned in <a href="multiprogramchapter.html" title="Chapter 7. Multiprogramming">Chapter 7</a> and <a href="generationchapter.html" title="Chapter 9. Generation">Chapter 9</a>) and what are now generally
called <i>scripting languages</i><a id="id2970833" class="indexterm"/>&#8212;those designed specifically to
glue together other applications and tools.</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>The term &#8220;scripting language&#8221; probably derives from
the term &#8220;script&#8221; that was applied to a potted input for
a normally interactive program, in particular sh or ed &#8212; a much
more felicitous term than the &#8220;runcom&#8221; we inherited from
Unix's ancestor CTSS<a id="id2970887" class="indexterm"/>.
&#8220;Script&#8221; appears in the V7 manual (1979).  I don't recall
who coined the name.</p></td><td width="10%" valign="top"> </td></tr><tr><td colspan="2" align="right" valign="top">--<span class="attribution">
<span class="author">Doug McIlroy</span>
<a id="id2970858" class="indexterm"/>
</span></td><td width="10%" valign="top"> </td></tr></table></div><p>In truth, the term &#8216;scripting language&#8217; is a
somewhat awkward one.  Many of the the major languages usually so
described (Perl, Tcl, Python, etc.) have outgrown the group's
scripting origins and are now standalone general-purpose programming
languages of considerable power.  The term tends to obscure strong
similarities in style with other languages that are not usually lumped
in with this group, notably Lisp and Java.  The only argument for
continuing to use it is that nobody has yet invented a better
term.</p><p>Part of the reason all these can be lumped together under the
rubric of &#8216;scripting language&#8217; is that they all have
pretty much the same ontogeny.  Having a runtime to do interpretation
also makes it relatively easy to automate dynamic storage management.
Automating dynamic storage management almost requires using references
(opaque memory addresses that you can't do arithmetic on) rather than
passing value copies or explicit pointers around.  Using references
makes runtime polymorphism and OO an easy next step.
<span class="foreignphrase"><i>Voila:</i></span> the modern scripting
language!</p><p>To apply the Unix philosophy effectively, you'll need to have
more than just C<a id="id2970941" class="indexterm"/> in your
toolkit. You'll need to learn how to use some of Unix's other
languages (especially the scripting languages), and how to be comfortable
mixing multiple languages in specialist roles within large program
systems.</p><p>In this chapter we'll survey C and its most important
alternatives, discussing their strengths and weaknesses and the
sorts of tasks to which they are best matched. The languages
covered will be C, C++, shell, Perl, Tcl, Python, Java, and Emacs
Lisp. Each survey section will include case studies on applications
written using these languages, and references to other examples and
tutorial material. High-quality implementations of all these
languages are available in open source on the Internet.</p><p>Warning: Choice of application language is one of the archetypal
religious issues in the Internet/Unix world. People get very attached
to these tools and will sometimes defend them past all reason. If this
chapter achieves its aim, zealots of all stripes may be offended by
this chapter, but everyone else will learn from it.</p><div class="footnotes"><br/><hr width="100" align="left"/><div class="footnote"><p><sup>[<a id="ftn.id2970798" href="#id2970798">122</a>] </sup>See the <a href="ftp://ftp.idiom.com/pub/compilers-list/free-compilers" target="_top">Free
Compiler and Interpreter List</a> for
details.</p></div></div></div></body></html>
