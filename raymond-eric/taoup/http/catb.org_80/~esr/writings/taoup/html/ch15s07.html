<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Profiling</title><meta name="generator" content="DocBook XSL Stylesheets V1.58.1"/><link rel="home" href="index.html" title="The Art of Unix Programming"/><link rel="up" href="toolschapter.html" title="Chapter&#160;15.&#160;Tools"/><link rel="previous" href="ch15s06.html" title="Runtime Debugging"/><link rel="next" href="ch15s08.html" title="Combining Tools with Emacs"/></head><body><mbp:pagebreak /><div class="sect1" lang="en"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="id2989334"/>Profiling</h2></div></div><p>As a general rule, 90% of the execution time of your program
will be spent in 10% of its code. Profilers are tools that help you
identify the 10% of hot spots that constrain the speed of your
program. This is a good thing for making it faster.</p><p>But in the Unix tradition, profilers have a far more important
function. They enable you <span class="emphasis"><em>not</em></span> to optimize the other 90%!
This is good, and not just because it saves you work. The
<span class="emphasis"><em>really</em></span> valuable effect is that not optimizing that 90%
holds down global complexity and reduces bugs.</p><p>You may recall that we quoted Donald
Knuth<a id="id2989368" class="indexterm"/>
observing &#8220;Premature optimization is the root of all
evil&#8221;<a id="id2989380" class="indexterm"/>
in <a href="philosophychapter.html" title="Chapter&#160;1.&#160;Philosophy">Chapter&#160;1</a>, and that
Rob Pike<a id="id2989400" class="indexterm"/> and Ken
Thompson<a id="id2989408" class="indexterm"/> had a
few pungent observations on the topic as well. These were the voices
of experience. Do good design.  Think about what's
<span class="emphasis"><em>right</em></span> first. Tune for efficiency later.</p><p>Profilers help you do this. If you get in the good habit of
using them, you can get rid of the bad habit of premature
optimization. Profilers don't just change the way you work; they
change how you think.</p><p>Profilers for compiled languages rely on instrumenting object
code, so they are even more platform-dependent than compilers. On the
other hand, a compiled-language profiler doesn't care about the source
language of the programs it instruments. Under Unix, the single
profiler
gprof(1)
handles C<a id="id2989450" class="indexterm"/>,
C++<a id="id2989458" class="indexterm"/>, and all
other compiled languages.</p><p>Perl<a id="id2989471" class="indexterm"/>,
Python<a id="id2989480" class="indexterm"/>, and
Emacs Lisp<a id="id2989488" class="indexterm"/> have their own profilers included in
their basic distributions; these are portable across all platforms on
which the host languages themselves run. Java<a id="id2989500" class="indexterm"/> has built-in profiling.
Tcl<a id="id2989508" class="indexterm"/> has no
profiling support as yet.</p></div></body></html>
