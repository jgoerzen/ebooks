<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Preface</title><link rel="stylesheet" href="taoup.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.58.1"/><link rel="home" href="index.html" title="The Art of Unix Programming"/><link rel="up" href="index.html" title="The Art of Unix Programming"/><link rel="previous" href="index.html" title="The Art of Unix Programming"/><link rel="next" href="pr01s01.html" title="Who Should Read This Book"/></head><body><mbp:pagebreak /><div class="preface" lang="en"><div class="titlepage"><div><h2 class="title"><a id="preface"/>Preface</h2></div></div><mbp:pagebreak /><div xmlns="" class="epigraph"><i><p xmlns="http://www.w3.org/1999/xhtml">Unix is not so much an operating system as an oral history.</p></i><span>--<i><span xmlns="http://www.w3.org/1999/xhtml" class="attribution">
<span class="author">Neal Stephenson</span>
<a id="id2871608" class="indexterm"/>
</span></i></span></div><p>There is a vast difference between knowledge and expertise.
Knowledge lets you deduce the right thing to do; expertise makes the
right thing a reflex, hardly requiring conscious thought at
all.</p><p>This book has a lot of knowledge in it, but it is mainly about
expertise. It is going to try to teach you the things about Unix
development that Unix experts know, but aren't aware that they
know. It is therefore less about technicalia and more about
<span class="emphasis"><em>shared culture</em></span> than most Unix books &#8212; both
explicit and implicit culture, both conscious and unconscious
traditions.  It is not a &#8216;how-to&#8217; book, it is a
&#8216;why-to&#8217; book.</p><p>The why-to has great practical importance, because far too much
software is poorly designed.  Much of it suffers from bloat, is
exceedingly hard to maintain, and is too difficult to port to new
platforms or extend in ways the original programmers didn't
anticipate.  These problems are symptoms of bad design.  We hope that
readers of this book will learn something of what Unix has to teach
about good design.</p><p>This book is divided into four parts: Context, Design, Tools,
and Community.  The first part (Context) is philosophy and history, to
help provide foundation and motivation for what follows.  The second
part (Design) unfolds the principles of the Unix philosophy into more
specific advice about design and implementation.  The third part
(Tools) focuses on the software Unix provides for helping you solve
problems.  The fourth part (Community) is about the human-to-human
transactions and agreements that make the Unix culture so effective at
what it does.</p><p>Because this is a book about shared culture, I never planned to
write it alone.  You will notice that the text includes guest
appearances by prominent Unix developers, the shapers of the Unix
tradition.  The book went through an extended public review process
during which I invited these luminaries to comment on and argue with
the text.  Rather than submerging the results of that review process
in the final version, these guests were encouraged to speak with their
own voices, amplifying and developing and even disagreeing with the
main line of the text.</p><p>In this book, when I use the editorial &#8216;we&#8217; it is
not to pretend omniscience but to reflect the fact that it attempts to
articulate the expertise of an entire community.</p><p>Because this book is aimed at transmitting culture, it includes
much more in the way of history and folklore and asides than is normal
for a technical book. Enjoy; these things, too, are part of your
education as a Unix programmer.  No single one of the historical
details is vital, but the gestalt of them all is important.  We think
it makes a more interesting story this way.  More
importantly, understanding where Unix came from and how it got the
way it is will help you develop an intuitive feel for the Unix
style.</p><p>For the same reason, we refuse to write as if history is over.
You will find an unusually large number of references to the time of
writing in this book.  We do not wish to pretend that current practice
reflects some sort of timeless and perfectly logical outcome of
preordained destiny. References to time of writing are meant as an
alert to the reader two or three or five years hence that the
associated statements of fact may have become dated and should be
double-checked.</p><p>Other things this book is not is neither a C tutorial, nor a
guide to the Unix commands and API. It is not a reference for
<i>sed</i> or <i>yacc</i> or
Perl or Python. It's not a network programming primer, nor an
exhaustive guide to the mysteries of X.  It's not a tour of Unix's
internals and architecture, either. Other books cover these specifics
better, and this book points you at them as appropriate.</p><p>Beyond all these technical specifics, the Unix culture has an
unwritten engineering tradition that has developed over literally
millions of man-years<sup>[<a id="id2871746" href="#ftn.id2871746">1</a>]</sup> of skilled effort. This
book is written in the belief that understanding that tradition, and
adding its design patterns to your toolkit, will help you become a
better programmer and designer.</p><p>Cultures consist of people, and the traditional way to learn
Unix culture is from other people and through the folklore, by
osmosis.  This book is not a substitute for person-to-person
acculturation, but it can help accelerate the process by allowing you
to tap the experience of others.</p><div class="footnotes"><br/><hr width="100" align="left"/><div class="footnote"><p><sup>[<a id="ftn.id2871746" href="#id2871746">1</a>] </sup>The three and a half decades
between 1969 and 2003 is a long time.  Going by the historical
trend curve in number of Unix sites during that period, probably
somewhere upwards of fifty million man-years have been plowed into
Unix development worldwide.</p></div></div></div></body></html>
