<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Language Evaluations</title><link rel="stylesheet" href="taoup.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.58.1"/><link rel="home" href="index.html" title="The Art of Unix Programming"/><link rel="up" href="languageschapter.html" title="Chapter 14. Languages"/><link rel="previous" href="ch14s03.html" title="Interpreted Languages and Mixed Strategies"/><link rel="next" href="ch14s05.html" title="Trends for the Future"/></head><body><mbp:pagebreak /><div class="sect1" lang="en"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="id2968458"/>Language Evaluations</h2></div></div><p>Mixing languages is a knowledge-intensive (rather than coding-intensive)
style of programming. To make it work, you have to have both
working knowledge of a suitable variety of languages and expertise
about what they're best at and how to fit them together. In this
section, we will try to point you at references to help you with the
first and an overview to convey the second. For each language
surveyed we will include case studies of successful programs that
exemplify its strengths.</p><div class="sect2" lang="en"><div class="titlepage"><div><h3 class="title"><a id="c_language"/>C</h3></div></div><a id="id2968486" class="indexterm"/><p>Despite the memory-management problem, there are some
application niches for which C is still king<a id="id2968501" class="indexterm"/>. Programs that require maximum speed, have
real-time requirements, or are tightly coupled to the OS kernel are
good candidates for C.</p><p>Programs that must be portable across multiple operating systems
may also be good candidates for C. Some of the alternatives to C that
we shall discuss below are, however, increasingly penetrating major
non-Unix operating systems; in the near future, portability may be less a
distinguishing advantage of C.</p><p>Sometimes the leverage to be gained from existing programs like
parser generators or GUI builders that generate C code is so great
that it justifies C coding of the rest of a small application.</p><p>And, of course, C proved indispensable to the developers of all
its alternatives. Dig down through enough implementation layers
under any of the other languages surveyed here and you will find a
core implemented in pure, portable C. These languages inherit 
many of the advantages of C.</p><p>Under modern conditions, it's perhaps best to think of C as a
high-level assembler for the Unix virtual machine (recall the
discussion of the success of C as a case study in <a href="modularitychapter.html" title="Chapter 4. Modularity">Chapter 4</a>).  C standards have exported many of the
facilities of this virtual machine, such as the standard I/O library,
to other operating systems.  C is where you go when you want to get as
close as possible to the bare metal but stay portable.</p><p>One good reason to learn C, even if your programming needs are
satisfied by a higher-level language, is that it can help you learn to
think at hardware-architecture level.  The best reference and tutorial
on C for people who are already programmers is still <i>The C
Programming Language</i> [<a href="apb.html#Kernighan-Ritchie" title="[Kernighan-Ritchie]">Kernighan-Ritchie</a>].</p><p>Porting C code between Unix variants is almost always possible
and usually easy, but specific areas of variation (like
signals and process control) can be tricky to get right.  We
highlight some of these issues in <a href="portabilitychapter.html" title="Chapter 17. Portability">Chapter 17</a>.  Differing C bindings on other
operating systems can of course cause C portability problems, although
Windows NT at least theoretically supports an ANSI/POSIX-compliant C
API.</p><p>High-quality C compilers are available as open-source software
over the Internet; the best-known and most widely used is the Free
Software Foundation's GNU C compiler (part of GCC, the GNU Compiler
Collection<a id="id2968603" class="indexterm"/>), which has become the native C of
all open-source Unix systems and many even in the closed-source
world. GCC ports are even available for
Microsoft's<a id="id2968614" class="indexterm"/> family of operating systems. GCC sources
are available at the FSF's <a href="ftp://ftp.gnu.org/pub/gnu" target="_top">FTP
site</a>.<a id="id2968631" class="indexterm"/></p><p>Summing up: C's best side is resource efficiency and
closeness to the machine.  Its worst side is that programming 
in it is a resource-management hell.</p><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="fetchmail"/>C Case Study:
<i>fetchmail</i></h4></div></div><a id="id2968660" class="indexterm"/><p>The best case study for C is the Unix kernel itself, for which a
language that naturally supports hardware-level operations is
actually a strong advantage. But
<i>fetchmail</i> is a good example of the kind of
user-land utility that is still best coded in C.</p><p><i>fetchmail</i> does only the simplest kind
of dynamic-memory management; its only complex data structure is a
singly-linked list of per-mailserver control blocks built just once,
at startup time, and changed only in fairly trivial ways
afterwards. This substantially erodes the case against using C by
sidestepping C's greatest weakness.</p><p>On the other hand, these control blocks are fairly complex
(including all of string, flag, and numeric data) and would be
difficult to handle as coherent fast-access objects in an
implementation language without an equivalent of the C struct
feature. Most of the alternatives to C are weaker than C in this
respect (Python<a id="id2968711" class="indexterm"/> and Java<a id="id2968719" class="indexterm"/> being notable exceptions).</p><p>Finally, <i>fetchmail</i> requires the
ability to parse a fairly complex specification syntax for
per-mail-server control information. In the Unix world this sort of
thing is classically handled by using C code generators that grind out
source code for a tokenizer and grammar parser from declarative
specifications. The existence of <i>yacc</i> and
<i>lex</i> was a point in favor of C.</p><p><i>fetchmail</i> might reasonably have been coded in
Python<a id="id2968769" class="indexterm"/>,
albeit with possibly significant loss of performance. Its size and
data-structure complexity would have excluded shell and
Tcl<a id="id2968780" class="indexterm"/> right off
and strongly counterindicated Perl<a id="id2968789" class="indexterm"/>, and the application domain is outside
the natural scope of Emacs Lisp<a id="id2968799" class="indexterm"/>. A Java<a id="id2968807" class="indexterm"/> implementation wouldn't have been an
unreasonable path, but Java's object-oriented style and garbage
collection would have offered little purchase on
<i>fetchmail</i>'s specific problems over what
C<a id="id2968826" class="indexterm"/> already
yields. Nor could C++<a id="id2968834" class="indexterm"/> have done much to simplify the
relatively simple internal logic of
<i>fetchmail</i>.</p><p>However, the real reason <i>fetchmail</i> is
a C program is that it evolved by gradual mutation from an ancestor
already written in C.  The existing implementation has been
extensively tested on many different platforms and against many odd
and quirky servers.  Carrying all that implicit knowledge through to a
re-implementation in a different language would be messy and
difficult.  Furthermore, <i>fetchmail</i> depends
on imported code for functions (like NTLM authentication) that don't
seem to be available above C level.</p><p><i>fetchmail</i>'s interactive configurator,
which did not have a C legacy problem, is written in Python; we'll
discuss that case along with that language.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><h3 class="title"><a id="cc_language"/>C++</h3></div></div><a id="id2968902" class="indexterm"/><p>When C++ was first released to the world in the mid-1980s
object-oriented (OO)<a id="id2968917" class="indexterm"/> languages were being widely touted
as the silver bullet for the software-complexity problem. C++'s OO
features appeared to be an overwhelming advantage over the ancestral
C, and partisans expected that it would rapidly make the older
language obsolete.</p><p>This has not happened. Part of the fault can be laid to problems
in C++ itself; the requirement that it be backward-compatible with C
forced a great many compromises on the design.  Among other things,
that requirement prevented C++ from going to fully automatic
dynamic-memory management and addressing C's most serious problem.
Later, feature arms races between different compiler implementers,
unconstrained by a weak and premature standardization effort, pushed
C++ to become rather baroque and excessively complicated.</p><p>Another part of the fault must be laid to the failure of
OO<a id="id2968949" class="indexterm"/> itself
to live up to expectations.  We examined this problem in <a href="modularitychapter.html" title="Chapter 4. Modularity">Chapter 4</a>, observing the tendency of OO methods to
lead to thick glue layers and maintenance problems.  Today
(2003), inspection of open-source archives (in which choice of
language reflects developers' judgments rather than corporate
mandates) reveals that C++ usage is still heavily concentrated in GUIs,
multimedia toolkits and games (the major success areas for OO
design), and little used elsewhere.</p><p>It may be that C++'s realization of OO<a id="id2968977" class="indexterm"/> is particularly problem-prone. There
is some evidence that C++ programs have higher life-cycle costs than
equivalents in C, FORTRAN, or Ada. Whether this is a problem with
OO<a id="id2968988" class="indexterm"/> or
specifically with C++ or both remains unclear, though there is reason
to suspect both are implicated [<a href="apb.html#Hatton98" title="[Hatton98]">Hatton98</a>].</p><p>In recent years, C++ has incorporated some important non-OO
ideas.  It has exceptions similar to those in
Lisp<a id="id2969010" class="indexterm"/>; that is,
it is possible to throw an object or value up the call stack until it
is caught by a handler.  STL (Standard Template Library) provides
generic programming; that is, it is possible to code algorithms that
are independent of the type signature of their data and have them
compiled to do the right thing at runtime. (Only languages that do
compile-time static type-checking need this; more dynamic languages
simply pass around typeless references and support type identification
at runtime.)</p><p>Efficient compiled language; upward-compatible with C;
object-oriented platform; vehicle for cutting-edge techniques like STL
and generics &#8212; C++ tries to be all things to all people, but the cost
is more complexity than the mind of any individual programmer can
handle. As we noted in <a href="modularitychapter.html" title="Chapter 4. Modularity">Chapter 4</a>, the language's principal designer has
conceded that he doesn't expect any one programmer to grasp it
all. Unix hackers do not react well to this; one anonymous but famous
characterization is &#8220;C++: an octopus made by nailing extra legs
onto a dog&#8221;.</p><p>When all is said and done, however, C++'s most fundamental
problem is that it is basically just another conventional language. It
confines the memory-management problem better than it did before the
invention of the Standard Template Library, and a lot better than C
does, but the confinement is brittle; it breaks unless your code
uses objects and only objects. For many types of application its
OO<a id="id2969066" class="indexterm"/>
features are not significant, and simply add complexity to C without
yielding much advantage. Open-source C++ compilers are available; if
C++ were unequivocally superior to C it would now dominate.</p><p>Summing up: C++'s best side is its combination of compiled
efficiency with facilities for OO<a id="id2969084" class="indexterm"/> and generic programming.  Its worst
side is that it is baroque and complex, and tends to encourage
over-complex designs.</p><p>Consider using C++ if an existing C++ toolkit or service library
offers powerful leverage for your application, or if you're in one of
the application areas mentioned above for which an
OO<a id="id2969102" class="indexterm"/>
language is known to be a large win.</p><p>The classic C++ reference is Stroustrup's <i>The C++
Programming Language</i> [<a href="apb.html#Stroustrup" title="[Stroustrup]">Stroustrup</a>]. You will find an excellent
beginner's tutorial on C++ and basic OO methods in <i>C++:
A Dialog</i> [<a href="apb.html#Heller" title="[Heller]">Heller</a>].
<i>C++ Annotations</i> [<a href="apb.html#Brokken" title="[Brokken]">Brokken</a>] is a condensed introduction to C++
for expert C programmers.</p><p>The Gnu Compiler Collection<a id="id2969153" class="indexterm"/> includes a C++ compiler. The language
is therefore universally available on Unix and on
Microsoft<a id="id2969163" class="indexterm"/> operating systems; comments made under C
above also apply here.  Strong collections of open-source <a href="http://www.boost.org/" target="_top"> support libraries</a> are available.
However, portability is compromised by the fact that (as of
mid-2003) actual C++ implementations implement widely varying subsets of the
draft ISO standard now in preparation.<sup>[<a id="id2969184" href="#ftn.id2969184">125</a>]</sup></p><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2969192"/>C++ Case Study: The Qt Toolkit</h4></div></div><p>The Qt interface toolkit is one of the notable C++ success
stories in today's open-source world. It provides a widget set and API
for writing graphical user interfaces under X, one deliberately (and
rather effectively) designed to emulate the visual look and feel of
Motif, MacOS Platinum<a id="id2969206" class="indexterm"/>, or the Microsoft
Windows<a id="id2969215" class="indexterm"/> interface.  Qt actually provides more
than just GUI services; it also provides a portable application layer,
with classes for XML, file access, sockets, threads, timers, time/date
handling, database access, various abstract data types, and
Unicode.</p><p>The Qt toolkit is a critical and visible component of the KDE
project, the senior of the open-source world's two efforts to
produce a competitive GUI and integrated set of desktop
productivity tools.</p><p>Qt's C++ implementation exhibits the strengths of an
OO<a id="id2969241" class="indexterm"/>
language for encapsulating user-interface components. In a language
supporting objects, a visual hierarchy of interface widgets can be
cleanly expressed in the code by a hierarchy of class instances. While
this sort of thing can be simulated in C<a id="id2969254" class="indexterm"/> with explicit indirection through
hand-rolled method tables, such code is much cleaner in C++.
Comparison with the notoriously baroque C API of Motif is
instructive.</p><p>The Qt source code and reference documentation are available at the
<a href="http://www.trolltech.com/" target="_top">Trolltech site</a>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><h3 class="title"><a id="sh"/>Shell</h3></div></div><a id="id2969290" class="indexterm"/><p>The &#8216;Bourne shell&#8217; (<i>sh</i>)
of Version 7 Unix was Unix's first (and for many years its only)
portable interpreted language. Today the ancestral Bourne shell has
largely been displaced by variants of the upward-compatible Korn
Shell<a id="id2969318" class="indexterm"/>
(<i>ksh</i>); the single most important of these
is the Bourne Again Shell, bash.</p><p>A few other shells exist and are used interactively, but are not
significant as programming languages; of these, the best known is
probably the C shell <i>csh</i>, which is
notoriously<sup>[<a id="id2969353" href="#ftn.id2969353">126</a>]</sup> unsuitable for writing
scripts.</p><p>Simple shell programs are extremely easy and natural to write.
The Unix tradition of rapid prototyping in interpretive languages
began with shell.</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>I wrote the very first version of netnews as a 150-line
shellscript.  It had multiple newsgroups and cross-posting;
newsgroups were directories and cross-posting was implemented
as multiple links to the article.  It was far too slow to
use for production, but the flexibility permitted endless
experimentation with the protocol design.</p></td><td width="10%" valign="top"> </td></tr><tr><td colspan="2" align="right" valign="top">--<span class="attribution">
<span class="author">Steven M. Bellovin</span>
<a id="id2975302" class="indexterm"/>
</span></td><td width="10%" valign="top"> </td></tr></table></div><p>As program size gets larger, however, they tend to become rather
ad-hoc. Some parts of shell syntax (notably its quoting and
statement-syntax rules) can be very confusing. These drawbacks
generally relate to compromises in the programming-language part of
the shell's design made to preserve its utility as an interactive
command-line interpreter.</p><p>Programs are described as being &#8216;in shell&#8217; even when
they are not pure shell but include heavy use of
C<a id="id2975339" class="indexterm"/> filters like
sort(1)
and of standard text-processing minilanguages like
sed(1)
or
awk(1). This
sort of programming has been in decline for some years, however;
nowadays such elaborate glue logic is generally written in
Perl<a id="id2975377" class="indexterm"/> or
Python<a id="id2975385" class="indexterm"/>, with
shell being reserved for the simplest kinds of wrappers (for which
these languages would be overkill) and system boot-time initialization
scripts (which cannot assume they are available).</p><p>Such basic shell programming should be adequately covered in any
introductory Unix book. <i>The Unix Programming
Environment</i> [<a href="apb.html#Kernighan-Pike84" title="[Kernighan-Pike84]">Kernighan-Pike84</a>] remains one of
the best sources on intermediate and advanced shell programming.  Korn
shell implementations or clones are present on every Unix.</p><p>Complex shellscripts often have portability problems, not so
much because of the shell itself but because they make assumptions
about what other programs are available as components.  While Bourne
and Korn-shell clones have been sporadically available on non-Unix
operating systems, shell programs are not (practically speaking) at
all portable off Unix.</p><p>Summing up: shell's best side is that it is very natural and
quick for small scripts.  Its worst side is that large shellscripts
depend on lots of auxiliary commands that aren't necessarily
identically behaved nor even present on all target machines.  Nor
is it easy to analyze the dependencies in a large shellscript.</p><p>It is almost never necessary to build or install a shell, since all
Unix systems and Unix emulators come equipped with them.  The standard
shell on Linux<a id="id2975443" class="indexterm"/> and other leading-edge Unix variants is
now <i>bash</i>.</p><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="xmlto"/>Case Study: <i>xmlto</i></h4></div></div><a id="id2975480" class="indexterm"/><p><i>xmlto</i> is a driver script
that calls all the commands needed to render an XML-DocBook document
as HTML, PostScript, plain text, or in any one of several other
formats (we'll take a closer look at DocBook in <a href="documentationchapter.html" title="Chapter 18. Documentation">Chapter 18</a>).  It is written
in bash.</p><p><i>xmlto</i> handles the details
of calling an XSLT engine with appropriate stylesheet, then handing
off the result to a postprocessor.  For HTML and XHTML the XSLT
transformation does the entire job.  For plain text, the XML is also
processed into HTML, but then handed to a postprocessor &#8212;
lynx(1)
in its <tt>-dump</tt> mode, which renders HTML to flat text.
For PostScript, the XML is transformed to XML FO (formatting
objects)<a id="id2975546" class="indexterm"/> which a
postprocessor then massages into <i>TeX</i> macros, to DVI<a id="id2975564" class="indexterm"/> format via
tex(1),
and then finally to PostScript via the well-known
dvi2ps(1)
tool.</p><p><i>xmlto</i> consists of a
single front-end shellscript.  It calls any one of several script
plugins, each named after the target format.  Each plugin is a
shellscript.  Depending on how it's called, it either supplies a
stylesheet for the front end to apply, or calls the appropriate
postprocessor(s) with various canned arguments.</p><p>This architecture means that all the information about a given
output format lives in one place (the corresponding script plugin), so
adding new output types can be done without disturbing the front-end
code at all.</p><p><i>xmlto</i> is a good example of a
medium-sized shell application.  Neither C<a id="id2975631" class="indexterm"/> nor C++ would have made sense
because they are awkward for scripting.  Any of the other scripting
languages in this chapter could have been used for this job; but it's
all simple command dispatching, with no internal data structures or
complex logic, so shell is good enough. Shell has the significant
advantage of being ubiquitous on the intended target systems.</p><p>In theory this script could run on any system supporting
<i>bash</i>.  The real constraint is the
requirement for one of the XSLT engines and all the postprocessors
needed to be present on the system.  In practice, this script is not
likely to run anywhere but under one of the modern open-source
Unixes.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2975671"/>Case Study: Sorcery Linux</h4></div></div><p>Sorcerer GNU/Linux is a Linux<a id="id2975680" class="indexterm"/> distribution that you install as a small,
bootable foothold system just powerful enough to run
bash(1)
and a couple of download utilities.  With this code in place, you can
invoke Sorcery, the Sorcerer package system.</p><p>Sorcery handles installing, removing, and integrity-checking
software packages.  When you &#8220;cast spells&#8221;, Sorcery
downloads the source code, compiles it, installs it, and saves a list
of files that were installed (along with a build log and checksums for
all the files).  Installed packages can be &#8220;dispelled&#8221; or
removed. Package listing and integrity checks are also available.
More details are available at the <a href="http://sorcerer.wox.org/" target="_top">Sorcery project site</a>.</p><p>The Sorcery system is written entirely in shell.  Program
installation procedures tend to be small, simple programs for which
shell is appropriate.  In this particular application, the main
drawback of shell is neutralized because Sorcery's authors can
guarantee that the helper programs they need will be present in the
foothold system.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><h3 class="title"><a id="perl"/>Perl</h3></div></div><a id="id2975751" class="indexterm"/><p>Perl is shell on steroids. It was specifically designed to
replace
awk(1),
and expanded to replace shell as the &#8216;glue&#8217; for
mixed-language script programming.<a id="id2975776" class="indexterm"/> It was first released in 1987.</p><p>Perl's strongest point is its extremely powerful built-in
facilities for pattern-directed processing of textual, line-oriented
data formats; it is unsurpassed at this. It also includes far stronger
data structures than shell, including dynamic arrays of mixed element
types and a &#8216;hash&#8217; or &#8216;dictionary&#8217; type that
supports convenient and fast lookup of name-value pairs.</p><p>Additionally, Perl includes a rather complete and
well-thought-out internal binding of virtually the entire Unix API,
drastically reducing the need for C<a id="id2975803" class="indexterm"/> and making it suitable for jobs like
simple TCP/IP<a id="id2975812" class="indexterm"/> clients
and even servers. Another strong advantage of Perl is that a large and
vigorous open-source community has grown up around it. Its home on
the net is the <a href="http://www.cpan.org/" target="_top">Comprehensive Perl
Archive Network</a>. Dedicated Perl hackers have written hundreds
of freely reusable Perl modules for many different programming
tasks. These include everything from structure-walking of directory
trees through X toolkits for GUI building, through excellent canned
facilities for supporting HTTP robots and CGI programming.</p><p>Perl's main drawback is that parts of it are irredeemably ugly,
complicated, and must be used with caution and in stereotyped ways
lest they bite (its argument-passing conventions for functions are a
good example of all three problems). It is harder to get started in
Perl than it is in shell<a id="id2975846" class="indexterm"/>. Though small programs in Perl can
be extremely powerful, careful discipline is required to maintain
modularity and keep a design under control as program size
increases. Because some limiting design decisions early in Perl's
history could not be reversed, many of the more advanced features have
a fragile, klugey feel about them.</p><p>The definitive reference on Perl is <i>Programming
Perl</i> [<a href="apb.html#Wall2000" title="[Wall2000]">Wall2000</a>]. This book has nearly
everything you will ever need to know in it, but is notoriously badly
organized; you will have to dig to find what you want. A more
introductory and narrative treatment is available in
<i>Learning Perl</i> [<a href="apb.html#Schwartz-Christiansen" title="[Schwartz-Christiansen]">Schwartz-Christiansen</a>].</p><p>Perl is universal on Unix systems.  Perl scripts at the same
major release level tend to be readily portable between Unixes
(provided they don't use extension modules). Perl implementations are
available (and even well documented) for the
Microsoft<a id="id2975898" class="indexterm"/> family of operating systems and on
MacOS<a id="id2975907" class="indexterm"/>
as well. Perl/Tk provides cross-platform GUI capability.</p><p>Summing up: Perl's best side is as a power tool for small glue
scripts involving a lot of regular-expression grinding.  Its worst
side is that it is ugly, spiky, and nigh-unmaintainable in large
volumes.</p><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2975926"/>A Small Perl Case Study: <i>blq</i></h4></div></div><p>The <i>blq</i> script is a tool
for querying block lists (lists of Internet sites that have been
identified as habitual sources of unsolicited bulk email, aka spam).
You can find current sources at the <a href="http://www.unicom.com/sw/blq/" target="_top"><i>blq</i>
project page</a>.</p><p><i>blq</i> is a good example of
a small Perl script, illustrating both the strengths and weaknesses of
the language. It makes intensive use of regular-expression matching.
On the other hand, the Net::DNS Perl extension module it uses has to
be conditionally included, because it is not guaranteed to be present
in any given Perl installation.</p><p><i>blq</i> is exceptionally
clean and disciplined as Perl code goes, and I recommend it as an
example of good style (the other Perl tools referenced from the
<i>blq</i> project page are good examples as
well).  But parts of the code are unreadable unless you are familiar
with very specific Perl idioms &#8212; the very first line of code,
<b>$0 =~ s!.*/!!;</b>, is an example.  While all languages
have some of this kind of opacity, Perl has it worse than most.</p><p>Tcl<a id="id2976030" class="indexterm"/> and
Python<a id="id2976038" class="indexterm"/> are
both good for small scripts of this type, but both lack the Perl
convenience features for regular-expression matching that <i>blq</i> uses heavily; an implementation in
either would have been reasonable, but probably less
compact<a id="id2976060" class="indexterm"/> and
expressive.  An Emacs Lisp<a id="id2976069" class="indexterm"/> implementation would have been even
faster to write and more compact than the Perl one, but probably
painfully slow to use.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2976082"/>A Large Perl Case Study:
<i>keeper</i></h4></div></div><p><i>keeper</i> is the tool used to file
incoming packages and maintain both FTP and WWW index files for the
huge Linux<a id="id2976109" class="indexterm"/> free-software archives at ibiblio. You
can find sources and documentation in the <a href="http://www.ibiblio.org/" target="_top">search tools subdirectory of the ibiblio
archive</a>.</p><p><i>keeper</i> is a good example of a
medium-to-large interactive Perl application. The command-line
interface is line-oriented and patterned after a specialized shell or
directory editor; note the embedded help facilities. The working parts
make heavy use of file and directory handling, pattern matching, and
pattern-directed editing. Note the ease with which
<i>keeper</i> generates Web pages and
electronic-mail notifications from programmatic templates. Note also
the use of a canned Perl module to automate walking various functions
over directory trees.</p><p>At about 3300 lines, this application is probably pushing the
size and complexity limit of what one should attempt in a single Perl
program. Nevertheless, most of it was written in a period of six
days. In C<a id="id2976166" class="indexterm"/>,
C++,<a id="id2976178" class="indexterm"/> or
Java<a id="id2976186" class="indexterm"/> it would
have taken a minimum of six weeks and been extremely difficult to
debug or modify after the fact. It is way too large for pure
Tcl<a id="id2976197" class="indexterm"/>. A
Python<a id="id2976206" class="indexterm"/>
version would probably be structurally cleaner, more readable, and
more maintainable &#8212; but also more verbose (especially near the
pattern-matching parts).  An Emacs Lisp<a id="id2976217" class="indexterm"/> mode could readily do the job, but
Emacs is not well suited for use over a
telnet link that is often slowed to a crawl by server
congestion.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><h3 class="title"><a id="tcl"/>Tcl</h3></div></div><a id="id2976241" class="indexterm"/><p>Tcl (Tool Command Language) is a small language interpreter
designed to link with compiled
C<a id="id2976256" class="indexterm"/> libraries, providing
scripted control of C code (<span class="emphasis"><em>extended
scripts</em></span>)<a id="id2976270" class="indexterm"/>.  Its original application was to
control libraries for electronic simulators (SPICE-like applications).
Tcl is also suitable for <span class="emphasis"><em>embedded scripts</em></span>&#8212;that 
is, scripts called from within C programs and returning values to
those programs.  Tcl had its first general public release in
1990.</p><p>Some facilities built on top of Tcl have achieved wide use outside
the Tcl community itself. The two most important of these are:</p><div class="itemizedlist"><ul type="disc"><li><p>The Tk toolkit, a kinder and gentler X interface that makes it
easy to rapidly build buttons, dialog boxes, menu trees, and
scrolling text widgets and collect input from them.</p></li><li><p>Expect, a language that makes it relatively easy to script
fully interactive programs with widely variable responses.</p></li></ul></div><p>The Tk toolkit is so important that the language is often
referred to as Tcl/Tk. Tk is also frequently used with
Perl<a id="id2976321" class="indexterm"/> and
Python<a id="id2976329" class="indexterm"/>.</p><p>The main advantage of Tcl itself is that it is extremely
flexible and radically simple. The syntax is very odd (based on a
positional parser) but totally consistent. There are no reserved
words, and there is no syntactic distinction between a function call
and &#8216;built in&#8217; syntax; thus the Tcl language interpreter
itself can be effectively redefined from within Tcl (which is what
makes projects like <i>Expect</i>
reasonable).</p><p>The main drawback of Tcl is that the pure language has only weak
facilities for namespace control and modularity, and two of them
(<b>upvar</b> and <b>uplevel</b>) are rather
dangerous if not used with great caution. Also, there are no data
structures other than association lists.  Tcl therefore scales up very
poorly &#8212; it is difficult to organize and debug pure Tcl programs of
even moderate size (more than a few hundred lines) without tripping
over your own feet. In practice, almost all large Tcl programs use one
of several OO<a id="id2976386" class="indexterm"/> extensions to the language.</p><p>The oddities of the syntax can at first be a problem as well; the
distinction between string quotes and braces will probably give you
headaches for a while, and the rules for when things need to be quoted
or braced are a bit tricky.</p><p>Pure Tcl only provides access to a relatively small
and commonly used part of the Unix API (essentially just file handling,
process-spawning, and sockets). Indeed, Tcl has the flavor of an
experiment in seeing how small a scripting
language<a id="id2976412" class="indexterm"/>
can get and still be useful.  Tcl extensions (similar to Perl modules)
provide a richer set of capabilities, but are (like CPAN modules) not
guaranteed to be installed everywhere.</p><p>The original Tcl reference is <i>Tcl and the Tk
Toolkit</i> [<a href="apb.html#Ousterhout94" title="[Ousterhout94]">Ousterhout94</a>], but that book has
been largely superseded by <i>Practical Programming in Tcl and
Tk</i> [<a href="apb.html#Welch" title="[Welch]">Welch</a>].  Brian Kernighan has written a
description of a real-world Tcl project [<a href="apb.html#Kernighan95" title="[Kernighan95]">Kernighan95</a>] that summarizes Tcl's strengths and weaknesses
as a rapid-prototyping and production tool; his contrast with
Microsoft Visual Basic is particularly balanced and
instructive.</p><p>The Tcl world doesn't have one central repository run by a core
group analogous to Perl's or Python's, but several excellent
websites both point to each other and cover most Tcl tool and
extension development. Look at the <a href="http://www.tcltk.com/" target="_top">Tcl Developer Xchange</a> first; among
other things, it offers Tcl sources of an interactive Tcl tutorial.
There is also a <a href="http://sourceforge.net/foundry/tcl-foundry/" target="_top">Tcl foundry at
SourceForge</a>.</p><p>Tcl scripts have portability problems similar to those of shell
scripts; the language itself is highly portable, but the components it
calls may not be.  Tcl implementations exist for the Microsoft family
of operating systems<a id="id2976493" class="indexterm"/>, MacOS<a id="id2976501" class="indexterm"/>, and many other platforms. Tcl/Tk scripts
will run on any platform with GUI capabilities.</p><p>Summing up: Tcl's best side is its spare,
compact<a id="id2976516" class="indexterm"/> design
and the
extensibility<a id="id2976525" class="indexterm"/>
of the Tcl interpreter.  Its worst side is the odd positional parser
and the weakness of its data structures and namespace controls; the
latter defect makes it scale poorly for large projects.</p><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2976538"/>Case Study: <i>TkMan</i></h4></div></div><p><i>TkMan</i> is a browser for Unix man pages
and Texinfo documents.  At roughly 1200 lines, it is quite large to be
written in pure Tcl, but the code is unusually well-modularized and
mature.  It uses Tk to provide a GUI interface quite a bit nicer than
either the stock
man(1)
or
xman(1)
utilities support.</p><p>TkMan makes a good case study because it exhibits almost the
full gamut of Tcl techniques.  Highlights include Tk integration, 
scripted control of other Unix applications (such as the Glimpse 
search engine), and the use of Tcl to parse Texinfo markup.</p><p>Any of the other languages would have made for a less direct
interface to the Tk GUI that constitutes most of this code.</p><p>A Web search for &#8220;TkMan&#8221; should turn up sources
and documentation.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2976607"/>Moodss: A Large Tcl Case Study</h4></div></div><p>The Moodss system is a graphical monitoring application for
system administrators.  It can watch logs and gather statistics for
MySQL, Linux, SNMP networks, and
Apache<a id="id2976619" class="indexterm"/>, and presents a
digested view of them through spreadsheet-like GUI panels called
&#8216;dashboards&#8217;. Monitoring modules can be written in
Python<a id="id2976630" class="indexterm"/> or
Perl<a id="id2976638" class="indexterm"/> as well as
Tcl.  The code is polished, mature, and considered an exemplar in the
Tcl community.  There is a <a href="http://jfontain.free.fr/moodss/" target="_top">project website</a>.</p><p>The Moodss core consists of about 18,000 lines of Tcl.  It uses
several Tcl extensions including a custom object system; the Moodss author
admits that without these &#8220;writing such a big application would 
not have been possible&#8221;.</p><p>Again, any of the other languages would have made for a less direct
interface to the Tk GUI that constitutes most of this code.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><h3 class="title"><a id="python_language"/>Python</h3></div></div><a id="id2976692" class="indexterm"/><p>Python is a scripting language<a id="id2976706" class="indexterm"/> designed for close integration with
C<a id="id2976715" class="indexterm"/>. It can both
import data from and export data to dynamically loaded C libraries,
and can be called as an embedded scripting language from C. Its syntax
is rather like a cross between that of C and the Modula family, but
has the unusual feature that block structure is actually controlled by
indentation (there is no analog of explicit begin/end or C curly
brackets).  Python was first publicly released in 1991.</p><p>The Python language is a very clean, elegant design with
excellent modularity features. It offers designers the option to write
in an object-oriented style but does not force that choice (it can be
coded in a more classically procedural C-like way). It has a type
system comparable in expressive power to
Perl's<a id="id2976742" class="indexterm"/>,
including dynamic container objects and association lists, but less
idiosyncratic (actually, it is a matter of record that
Perl's<a id="id2976752" class="indexterm"/> object
system was built in imitation of Python's). It even pleases
Lisp<a id="id2976762" class="indexterm"/> hackers
with anonymous lambdas (function-valued objects that can be passed
around and used by iterators). Python ships with the Tk toolkit, which
can be used to easily build GUI interfaces.</p><p>The standard Python distribution includes client classes for
most of the important Internet protocols (SMTP, FTP, POP3, IMAP, HTTP)
and generator classes for HTML. It is therefore very well suited to
building protocol robots and network administrative plumbing. It is
also excellent for Web CGI work, and competes successfully with
Perl<a id="id2976784" class="indexterm"/> at the
high-complexity end of that application area.</p><p>Of all the interpreted languages we describe, Python and
Java<a id="id2976799" class="indexterm"/> are the
two most clearly suited for scaling up to large complex projects
with many cooperating developers. In many ways Python is simpler than
Java, and its friendliness to rapid prototyping may give it an edge
over Java for standalone use in applications that are neither hugely
complex nor speed critical. An implementation of Python in Java,
designed to facilitate mixed use of these two languages, is available
and in production use; it is called Jython.</p><p>Python cannot compete with C<a id="id2976821" class="indexterm"/> or C++<a id="id2976832" class="indexterm"/> on raw execution speed (though using a
mixed-language strategy on today's fast processors probably makes that
relatively unimportant). In fact it's generally thought to be the
least efficient and slowest of the major scripting languages, a price
it pays for runtime type polymorphism.  Beware of rejecting Python on
these grounds, however; most applications do not actually need better
performance than Python offers, and even those that appear to are
generally limited by external latencies such as network or disk waits
that entirely swamp the effects of Python's interpretive
overhead. Also, by way of compensation, Python is exceptionally easy
to combine with C, so performance-critical Python modules can be readily
translated into that language for substantial speed gains.</p><p> Python loses in expressiveness to
Perl<a id="id2976860" class="indexterm"/> for small
projects and glue scripts heavily dependent on regular-expression
capability. It would be overkill for tiny projects, to which
shell<a id="id2976872" class="indexterm"/> or
Tcl<a id="id2976880" class="indexterm"/> might be
better suited.</p><p>Like Perl, Python has a well-established development community
with a <a href="http://www.python.org/" target="_top">central website</a>
carrying a great many useful Python implementations, tools and
extension modules.</p><p>The definitive Python reference is <i>Programming
Python</i> [<a href="apb.html#Lutz" title="[Lutz]">Lutz</a>]. Extensive
on-line documentation on Python extensions is also available at the
Python website.</p><p>Python programs tend to be quite portable between Unixes and even
across other operating systems; the standard library is powerful
enough to significantly cut the use of nonportable helper programs.
Python implementations are available for
Microsoft<a id="id2976928" class="indexterm"/> operating systems and for
MacOS<a id="id2976937" class="indexterm"/>. Cross-platform GUI development is
possible with either Tk or two other toolkits. Python/C applications
can be &#8216;frozen&#8217;, quasi-compiled into pure C sources that
should be portable to systems with no Python installed.</p><p>Summing up: Python's best side is that it encourages clean,
readable code and combines accessibility with scaling up well to large
projects.  Its worst side is inefficiency and slowness, not just
relative to compiled languages but relative to other scripting
languages as well.</p><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2976960"/>A Small Python Case Study: <i>imgsizer</i></h4></div></div><p>Imgsizer is a utility that rewrites WWW pages so that
image-inclusion tags get the right image size parameters
automatically plugged in (this speeds up page loading on many
browsers). You can find sources and documentation in the URL <a href="http://www.ibiblio.org/" target="_top">WWW tools
subdirectory of the ibiblio archive</a>.</p><p><i>imgsizer</i> was originally written in
Perl<a id="id2977002" class="indexterm"/>, and was a
nearly ideal example of the sort of small, pattern-driven
text-processing tool at which Perl excels.  It was later translated to
Python to take advantage of Python's library support for HTTP
fetching; this eliminated a dependency on an external page-fetching
utility.  Observe the use of
file(1)
and ImageMagick
identify(1)
as specialist tools for extracting the pixel sizes of images.</p><p>The dynamic string handling and sophisticated regular-expression
matching required would have made <i>imgsizer</i> quite painful to write in
C<a id="id2977050" class="indexterm"/> or C++<a id="id2977061" class="indexterm"/>; that version would also have been much
larger and harder to read. Java would have solved the implicit
memory-management problem, but is hardly more expressive than
C or C++<a id="id2977073" class="indexterm"/> at text pattern matching.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2977085"/>A Medium-Sized Python Case Study:
<i>fetchmailconf</i></h4></div></div><p>In <a href="interfacechapter.html" title="Chapter 11. Interfaces">Chapter 11</a> we
examined the
<i>fetchmail</i>/<i>fetchmailconf</i>
pair as an example of one way to separate implementation from
interface.  Python's strengths are well illustrated by 
<i>fetchmailconf</i>.</p><p><i>fetchmailconf</i> uses the Tk
toolkit to implement a multi-panel GUI configuration editor (Python
bindings also exist for GTK+ and other toolkits, but Tk bindings ship
with every Python interpreter).</p><p>In expert mode, the GUI supports editing of about sixty
attributes divided among three panel levels. Attribute widgets include
a mix of checkboxes, radio buttons, text fields, and scrolling
listboxes. Despite this complexity, the first fully-functional version
of the configurator took me less than a week to design and code,
counting the four days it took to learn Python and Tk.</p><p>Python excels at rapid prototyping of GUI interfaces, and (as
<i>fetchmailconf</i> illustrates) such prototypes are often deliverable.
Perl<a id="id2977168" class="indexterm"/> and
Tcl<a id="id2977176" class="indexterm"/> have similar
strengths in this area (including the Tk toolkit, which was written
for Tcl) but are hard to control at the complexity level
(approximately 1400 lines) of <i>fetchmailconf</i>. Emacs
Lisp<a id="id2977195" class="indexterm"/> is
not suited for GUI programming. Choosing Java<a id="id2977204" class="indexterm"/> would have increased the complexity
overhead of this programming task without delivering significant
benefits for this nonspeed-intensive application.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2977218"/>A Large Python Case Study: PIL</h4></div></div><p>PIL, the Python Imaging Library, supports the manipulation of
bitmap graphics. It supports many popular formats, including
PNG<a id="id2977229" class="indexterm"/>, JPEG, BMP, TIFF,
PPM, XBM, and GIF. Python programs can use it to convert and transform
images; supported transformations include cropping, rotation, scaling,
and shearing. Pixel editing, image convolution, and color-space
conversions are also supported. The PIL distribution includes Python
programs that make these library facilities available from the
command line. Thus PIL can be used either for batch-mode image
transformation or as a strong toolkit over which to implement
program-driven image processing of bitmaps.</p><p>The implementation of PIL illustrates the way Python can be
readily augmented with loadable object-code extensions to the Python
interpreter. The library core, implementing fundamental operations on
bitmap objects, is written in
C<a id="id2977256" class="indexterm"/> for speed. The upper
levels and sequencing logic are in Python, slower but much easier to
read and modify and extend.</p><p>The analogous toolkit would be difficult or impossible to write
in Emacs Lisp<a id="id2977272" class="indexterm"/> or shell<a id="id2977280" class="indexterm"/>, which don't have or don't document
a C extension interface at all.  Tcl<a id="id2977290" class="indexterm"/> has a good C extension facility, but
PIL would be an uncomfortably large project in Tcl.
Perl<a id="id2977300" class="indexterm"/> has such
facilities (Perl XS), but they are ad-hoc, poorly documented, complex,
and unstable by comparison to Python's and use of them is
rare. Java's<a id="id2977311" class="indexterm"/>
Native Method Interface appears to provide a facility roughly
comparable to Python's; PIL would probably have made a reasonable Java
project.</p><p>The PIL code and documentation is available at the <a href="http://www.pythonware.com/products/pil/" target="_top">project
website</a>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><h3 class="title"><a id="java"/>Java</h3></div></div><a id="id2977347" class="indexterm"/><p>The Java programming language was designed to be &#8220;write
once, run anywhere&#8221; and to support embedding interactive
programs (or <i>applets</i>) in Web pages that would
be runnable from any browser. Thanks to a series of technical and
strategic blunders by its owner, Sun
Microsystems<a id="id2977374" class="indexterm"/>, it has failed in both its original
objectives.  But it is still sufficiently strong at both systems and
applications programming to be seriously challenging
C<a id="id2977385" class="indexterm"/> and C++<a id="id2977397" class="indexterm"/>.  Java was announced in 1995.</p><p>Java is cleverly designed to capture the huge benefit of
automatic memory management and the lesser but not insignificant
benefit of supporting OO<a id="id2977412" class="indexterm"/> design, while being far smaller and
simpler than C++<a id="id2977422" class="indexterm"/>. It retains a broadly C-like syntax
that most programmers will find comfortable. It includes support for
callouts to dynamically-loaded C and calling Java as an embedded
language from C.  Nor is it trivial that Sun<a id="id2977434" class="indexterm"/> has done an excellent job of making
good Java documentation available on the Web.</p><p>Against Java, we can say that (compared to, say,
Python<a id="id2977449" class="indexterm"/>) some
parts of it appear over-complex and others deficient. Java's
class-visibility and implicit-scoping rules are baroque. The interface
facility avoids complex problems with multiple inheritance at the cost
of being only slightly less difficult to understand and use in itself.
Features like inner and anonymous classes can lead to very confusing
code. The absence of reliable destructor methods means that it is
difficult to ensure proper management of resources other than memory,
such as mutexes and file locks.  Significant parts of the Unix
operating-system facilities are not accessible from stock Java,
including signals, poll, and select.  While Java's I/O facilities are
very powerful, simple reading of text files is not simple.</p><p>There is a particularly invidious problem, resembling Windows
DLL hell, with libraries.  Java has no method to manage
different library versions. This can create huge problems in
environments like application servers, where the server might come
equipped with one version of (say) an XML library, but the application
ships with a different (usually newer) version.  The only handle on
such problems is the <tt>CLASSPATH</tt> environment variable,
a source of chronic deployment problems.</p><p>Furthermore, Sun's handling of the Java language has been both
politically and technically obtuse. Java's first GUI toolkit, AWT, was
a mess that had to be essentially replaced. Withdrawing the language
from ECMA/ISO standardization further nettled many developers already
upset by features of the Sun Community Source License (SCSL).
Restrictions in the SCSL continue to hamper open-source
implementations of Java 1.2 and their J2EE (Java 2 Enterprise Edition)
specification.  This compromises Java's original objective of
universal portability.</p><p>Sadly, browser applets are dead.
Microsoft's<a id="id2977508" class="indexterm"/>
decision not to support Java 1.2 in Internet Explorer effectively
killed them.  However, Java seems to have found a secure niche in the
computing ecology, for &#8216;servlets&#8217; running within Web
application servers.  It has also become commonly used for a lot of
in-house corporate programming not directly tied to databases or
webservers.  It has become major competition for both Microsoft's
ASP/COM platform and Perl CGIs.  Finally, it is in widespread and
increasing use as a language for teaching introductory programming (a
role for which it is extremely well suited).</p><p>Overall, we can fairly judge Java to be superior to
C++<a id="id2977532" class="indexterm"/> (which is
both far more complex and does less to attack the memory-management
problem) for all but systems programming and the most speed-critical
applications.  Experience seems to show that Java programmers are
somewhat less likely to fall into the trap of excessive
OO<a id="id2977546" class="indexterm"/>
layering than are C++ programmers, though this remains a significant
problem.</p><p>How Java will fare in equilibrium with the other languages
we describe here is unclear as yet, and may depend largely on project
scale. We may expect its proper niche to resemble
Python's<a id="id2977563" class="indexterm"/>. Like Python, it cannot compete with
C<a id="id2977572" class="indexterm"/> or
C++<a id="id2977581" class="indexterm"/> on raw
execution speed, nor against Perl<a id="id2977590" class="indexterm"/> on small projects that use
pattern-driven editing heavily. It is (more definitely than Python)
overkill for small projects. We may guess that Python will have an
edge in smaller projects and Java in larger ones, but the verdict of
experience is not yet in.</p><p>The best single reference on paper is probably <i>Java
In A Nutshell</i> [<a href="apb.html#FlanaganJava" title="[FlanaganJava]">FlanaganJava</a>], but this is
not the best tutorial introduction; that would probably be
<i>Thinking in Java</i> [<a href="apb.html#Eckel" title="[Eckel]">Eckel</a>]. Trails to all the world's Java websites begin at
<a href="http://java.sun.com/" target="_top">Sun's Java site</a>, which also
has complete HTML documentation available for download for free. The
<a href="http://dmoz.org/Computers/Programming/Languages/Java/" target="_top">Open
Directory Java Page</a> also collects useful Java links.</p><p>Java implementations are available for all Unixes, for
Microsoft operating systems<a id="id2977652" class="indexterm"/>, MacOS<a id="id2977661" class="indexterm"/>, and many other platforms.</p><p>Sources for Kaffe, an open-source Java implementation with class
libraries conforming to most of JDK 1.1 and portions of JDK 1.2,
are available at the <a href="http://www.kaffe.org/" target="_top">Kaffe project site</a>.</p><p>There is a Java front end for GCC. GCJ can compile Java code to
either Java bytecode or native code, and can compile Java bytecode to
native code as well. It comes packaged with open-source class
libraries that implement most of JDK 1.2, and a Java bytecode
interpreter called <i>gij</i>. Details are at the
<a href="http://gcc.gnu.org/java/" target="_top">GCJ project page</a>.</p><p>There is a Java IDE for Emacs at the <a href="http://jdee.sunsite.dk/" target="_top">JDEE project site</a>.</p><p>Java portability is excellent at the language level.  Incomplete
library implementations (especially older JDK 1.1 versions that don't
support the newer JDK 1.2) can be an issue. </p><p>Java's best side is that it comes close enough to
achieving write-once-run-anywhere to be useful as an OS-independent
environment of its own.  Its worst side is that the Java 1/Java 2
split compromises that goal in deeply frustrating ways.</p><div class="sect3" lang="en"><div class="titlepage"><div><h4 class="title"><a id="id2977737"/>Case Study: FreeNet</h4></div></div><p>Freenet is a peer-to-peer networking project that is intended to
make censorship and content suppression
impossible.<sup>[<a id="id2977747" href="#ftn.id2977747">127</a>]</sup>  Freenet developers envision the
following applications:</p><div class="itemizedlist"><ul type="disc"><li><p>Uncensorable dissemination of controversial information: Freenet
protects freedom of speech by enabling anonymous and uncensorable
publication of material ranging from grassroots alternative journalism
to banned exposés.</p></li><li><p>Efficient distribution of high-bandwidth content: Freenet's
adaptive caching and mirroring is being used to distribute Debian
Linux software updates.</p></li><li><p>Universal personal publishing: Freenet enables anyone to have a
website, without space restrictions or compulsory advertising, even if
the would-be webmaster doesn't own a computer.</p></li></ul></div><p>Freenet addresses these goals by providing a virtual space in
which to publish documents that is not tied to any specific machine.
Published information and Freenet's own internal data indexes are
replicated and distributed across the network in such a way that even
Freenet administrators don't know at any given time where all the physical
copies are located.  Privacy for people browsing or submitting to
Freenet is protected by strong cryptography.</p><p>Java was a good choice for this project for at least two reasons.
First: the goals of the project put a heavy premium on having
compatible implementations on the widest possible variety of machines,
so Java's high portability is a dominating advantage.  Second: the
nature of the project is such that the network API is important,
and Java has a strong one built in.</p><p>C is traditional for infrastructure projects of this kind that
have high performance demands, but the lack of a standardized network
API would have made porting a significant difficulty.  C++ would have
had the same difficulty.  Tcl<a id="id2977833" class="indexterm"/>, Perl<a id="id2977842" class="indexterm"/>, or Python<a id="id2977850" class="indexterm"/> might have reduced the porting burden,
but at a greater cost in performance.  Emacs Lisp
<a id="id2977860" class="indexterm"/> would
have been painfully slow and totally inappropriate.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><h3 class="title"><a id="emacs_lisp_language"/>Emacs Lisp</h3></div></div><a id="id2977882" class="indexterm"/><p>Emacs Lisp is a scripting language<a id="id2977896" class="indexterm"/> used to program the behavior of the
Emacs text editor.  Its first public release was in 1984.</p><p>Emacs Lisp is not a general-purpose language in quite the same
way as the others surveyed in this chapter; while it is powerful
enough to theoretically be used as such, it is traditionally employed
only to write control programs for the
Emacs editor itself and does not
communicate as fluently with other software as would a modern
scripting language.</p><p>Nevertheless, there is a significant range of applications in
which Emacs Lisp is more effective than anything else. Many of these
have to do with providing a front-end for development tools such as
the C compiler and linker,
make(1),
version-control systems, and symbolic debuggers; we'll discuss these
in <a href="toolschapter.html" title="Chapter 15. Tools">Chapter 15</a>.</p><p>More generally, Emacs is to pattern-
or syntax-directed <span class="emphasis"><em>interactive</em></span> editing what
Perl<a id="id2977953" class="indexterm"/> is to
pattern-directed <span class="emphasis"><em>batch</em></span> editing. Any application
that involves interactively hacking a special file format or text
database is an excellent candidate to be prototyped (and possibly
delivered) as an Emacs mode (an Emacs Lisp
program that specializes the editor's behavior).</p><p>Emacs Lisp is also valuable for building applications that have
to be closely integrated with a text editor, or that function
primarily as text browsers with some editing capability. User agents
for email and Usenet<a id="id2977979" class="indexterm"/>
news fall in this category. So do certain kinds of database front
ends.</p><p>Emacs Lisp is a Lisp. It follows as the night the day that it
manages memory automatically and is far more elegant and powerful than
most conventional languages, or indeed most
<span class="emphasis"><em>unconventional</em></span> languages; it can compete with
Java<a id="id2978000" class="indexterm"/> or
Python<a id="id2978009" class="indexterm"/> on
this level and laugh at C<a id="id2978018" class="indexterm"/> or C++<a id="id2978029" class="indexterm"/>, Perl<a id="id2978038" class="indexterm"/>, shell or Tcl<a id="id2978046" class="indexterm"/>. Lisp's perennial problem of lacking a
standardized OS binding for portability is solved by the Emacs core,
which in effect <span class="emphasis"><em>is</em></span> its OS binding.</p><p>Lisp's other perennial problem &#8212; being a resource hog
&#8212; is no longer a real issue on modern machines. Parody
expansions like &#8216;Emacs Makes A Computer Slow&#8217; and
&#8216;Eventually Munches All Computer Storage&#8217; used to be
common (in fact the Emacs distribution itself includes a list of
them). But many other commonly used categories of programs (such as
Web browsers) have nowadays grown larger and more complex than Emacs,
which has come to appear rather moderate by comparison.</p><p>The definitive Emacs Lisp reference is <span class="emphasis"><em>The GNU Emacs
Lisp Reference Manual</em></span>, which may be browseable through your
Emacs's &#8216;info&#8217; help system. If not, it can be downloaded from the
<a href="ftp://ftp.gnu.org/pub/gnu" target="_top">FSF FTP<a id="id2978092" class="indexterm"/> site</a>. If you
find that impenetrable, <i>Writing GNU Emacs
Extensions</i> [<a href="apb.html#Glickstein" title="[Glickstein]">Glickstein</a>] may help.</p><p>Portability of Emacs Lisp programs is excellent.
Emacs implementations are available for all
Unixes, the Microsoft operating systems<a id="id2978119" class="indexterm"/>, and Mac
OS<a id="id2978128" class="indexterm"/>.</p><p>Summing up: Emacs Lisp's best point is that it combines an
excellent base language, Lisp<a id="id2978142" class="indexterm"/>, with powerful domain primitives for
text manipulation.  Its worst point is poor performance and
difficulties using it in communication with other programs.</p><p>For more information, see the discussion of
<i>Emacs</i> under editors in the next
chapter.</p></div><div class="footnotes"><br/><hr width="100" align="left"/><div class="footnote"><p><sup>[<a id="ftn.id2969184" href="#id2969184">125</a>] </sup>The last C++ standard,
dating from 1998, was widely implemented but weak, especially in the 
area of libraries.</p></div><div class="footnote"><p><sup>[<a id="ftn.id2969353" href="#id2969353">126</a>] </sup>See Tom Christiansen's essay <i>Csh
Programming Considered Harmful</i>, which should be readily
findable via Web search.</p></div><div class="footnote"><p><sup>[<a id="ftn.id2977747" href="#id2977747">127</a>] </sup>There is a <a href="http://freenetproject.org/" target="_top">Freenet project
website</a>.</p></div></div></div></body></html>
