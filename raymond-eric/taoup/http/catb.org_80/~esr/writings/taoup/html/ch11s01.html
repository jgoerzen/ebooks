<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Applying the Rule of Least Surprise</title><link rel="stylesheet" href="taoup.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.58.1"/><link rel="home" href="index.html" title="The Art of Unix Programming"/><link rel="up" href="interfacechapter.html" title="Chapter 11. Interfaces"/><link rel="previous" href="interfacechapter.html" title="Chapter 11. Interfaces"/><link rel="next" href="ch11s02.html" title="History of Interface Design on Unix"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Applying the Rule of Least Surprise</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="interfacechapter.html">Prev</a> </td><th width="60%" align="center">Chapter 11. Interfaces</th><td width="20%" align="right"> <a accesskey="n" href="ch11s02.html">Next</a></td></tr></table><hr/></div><div class="sect1" lang="en"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="id2952650"/>Applying the Rule of Least Surprise</h2></div></div><p>The Rule of Least Surprise is a general principle in the design
of all kinds of interfaces, not just software: &#8220;Do the least
surprising thing&#8221;. It's a consequence of the fact that human
beings can only pay attention to one thing at one time (see
<i>The Humane Interface</i> [<a href="apb.html#Raskin" title="[Raskin]">Raskin</a>]).  Surprises in the interface focus
that single locus of attention on the interface, rather than on the
task where it belongs.</p><p>Thus, to design usable interfaces, it's best when possible not
to design an entire new interface model. Novelty is a barrier to
entry; it puts a learning burden on the user, so minimize it. Instead,
think carefully about the experience and knowledge of your user
base. Try to find functional similarities between your program and
programs they are likely to already know about. Then mimic the
relevant parts of the existing interfaces.</p><p>The Rule of Least Surprise should not be interpreted as a call
for mechanical conservatism in design. Novelty raises the cost of a
user's first few interactions with an interface, but poor design
will make the interface needlessly painful forever. As in other
sorts of design, rules are not a substitute for good taste and
engineering judgment. Consider your tradeoffs carefully &#8212; and
consider them from the <span class="emphasis"><em>user's</em></span> point of view. The bias
implied by the Rule of Least Surprise is a good one to hold
consciously, mainly because interface designers (like other
programmers) have an unconscious tendency to be too clever for the
user's good.</p><p>One implication of the Rule of Least Surprise is this: Wherever
possible, allow the user to delegate interface functions to a familiar
program. We already observed in <a href="multiprogramchapter.html" title="Chapter 7. Multiprogramming">Chapter 7</a> that, if your program requires the
user to edit significant amounts of text, you should write it to call
an editor (specifiable by the user) rather than building in your own
integrated editor.  This will enable the <span class="emphasis"><em>users</em></span>,
who know their preferences better than you, to choose the least
surprising alternative.</p><p>Elsewhere in this book we have advocated symbiosis and
delegation as tactics for promoting code reuse and minimizing
complexity. The point here is that when users can intercept the
delegation, and direct it to an agent of their own choice,
these techniques become not merely economical for the developer but
actively empowering to users.</p><p>Further: When you can't delegate, emulate. The purpose of the
Rule of Least Surprise is to reduce the amount of complexity a user
must absorb to use an interface. Continuing the editor example, this
means that if you must implement an embedded editor, it's best if the
editor commands are a subset of those for a well-known general-purpose
editor. (Or more than one.  Both <i>bash</i> and
<i>ksh</i> have command-line editors that allow
the user to choose between <i>vi</i> and
<i>Emacs</i> editing styles.)</p><p>Under the Unix versions of the Netscape and Mozilla Web
browsers, for example, fill-in fields in forms recognize a subset of
the default bindings for the <i>Emacs</i>
editor. Control-A goes to start of line, Control-D deletes the next
character, and so forth. This choice helps people who know
<i>Emacs</i>, and leaves others no worse off than
an arbitrary, idiosyncratic command set would have. The only way it
could have been bettered was by choosing key bindings associated with
some editor significantly more widely used than
<i>Emacs</i>; and among Netscape's original user
population there was no such animal.</p><p>These principles can be applied in many other areas of interface
design. They suggest, for example, that it is deeply foolish to create
novel document formats for an on-line help system when users are
comfortable with an HTML Web browser. Or even that if you are
designing an arcade-style game, it is wise to look at the gesture sets
of previous games to see if you can give new users a feeling of
comfort by allowing them to transfer joystick skills learned in other
games.</p></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="interfacechapter.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="interfacechapter.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch11s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 11. Interfaces </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> History of Interface Design on Unix</td></tr></table></div></body></html>
