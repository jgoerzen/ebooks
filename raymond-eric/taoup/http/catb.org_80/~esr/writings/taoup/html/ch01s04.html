<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>What Unix Gets Wrong</title><link rel="stylesheet" href="taoup.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.58.1"/><link rel="home" href="index.html" title="The Art of Unix Programming"/><link rel="up" href="philosophychapter.html" title="Chapter 1. Philosophy"/><link rel="previous" href="ch01s03.html" title="The Case against Learning Unix Culture"/><link rel="next" href="ch01s05.html" title="What Unix Gets Right"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">What Unix Gets Wrong</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s03.html">Prev</a> </td><th width="60%" align="center">Chapter 1. Philosophy</th><td width="20%" align="right"> <a accesskey="n" href="ch01s05.html">Next</a></td></tr></table><hr/></div><div class="sect1" lang="en"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="id2808649"/>What Unix Gets Wrong</h2></div></div><p>For a design that dates from 1969, it is remarkably difficult
to identify design choices in Unix that are unequivocally wrong.
There are several popular candidates, but each is still a subject of
spirited debate not merely among Unix fans but across the wider
community of people who think about and design operating
systems.</p><p>Unix files have no structure above byte level. File deletion is
irrevocable.  The Unix security model is arguably too primitive.  Job
control is botched.  There are too many different kinds of names for
things.  Having a file system at all may have been the wrong choice.
We will discuss these technical issues in <a href="futurechapter.html" title="Chapter 20. Futures">Chapter 20</a>.</p><p>But perhaps the most enduring objections to Unix are consequences of
a feature of its philosophy first made explicit by the designers of
the X windowing system<a id="id2808686" class="indexterm"/>. X strives to provide &#8220;mechanism,
not policy&#8221;, supporting an extremely general set of graphics
operations and deferring decisions about toolkits and interface
look-and-feel (the policy) up to application level. Unix's other
system-level services display similar tendencies; final choices about
behavior are pushed as far toward the user as possible. Unix users
can choose among multiple shells. Unix programs normally provide many
behavior options and sport elaborate preference facilities.</p><p>This tendency reflects Unix's heritage as an operating system
designed primarily for technical users, and a consequent belief that
users know better than operating-system designers what their own needs
are.</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>This tenet was firmly established at Bell Labs by Dick
Hamming<sup>[<a id="id2808745" href="#ftn.id2808745">5</a>]</sup> who insisted in
the 1950s when computers were rare and expensive, that open-shop
computing, where customers wrote their own programs, was imperative,
because &#8220;it is better to solve the right problem the wrong way
than the wrong problem the right way&#8221;.</p></td><td width="10%" valign="top"> </td></tr><tr><td colspan="2" align="right" valign="top">--<span class="attribution">
<span class="author">Doug McIlroy</span>
<a id="id2808731" class="indexterm"/>
</span></td><td width="10%" valign="top"> </td></tr></table></div><p>But the cost of the mechanism-not-policy approach is that when
the user <span class="emphasis"><em>can</em></span> set policy, the user
<span class="emphasis"><em>must</em></span> set policy. Nontechnical end-users
frequently find Unix's profusion of options and interface styles
overwhelming and retreat to systems that at least pretend to offer
them simplicity.</p><p>In the short term, Unix's laissez-faire approach may lose it a
good many nontechnical users. In the long term, however, it may turn
out that this &#8216;mistake&#8217; confers a critical advantage
&#8212; because policy tends to have a short lifetime, mechanism a
long one. Today's fashion in interface look-and-feel too often becomes
tomorrow's evolutionary dead end (as people using obsolete X toolkits
will tell you with some feeling!). So the flip side of the flip side
is that the &#8220;mechanism, not policy&#8221; philosophy may enable
Unix to renew its relevance long after competitors more tied to one
set of policy or interface choices have faded from
view.<sup>[<a id="id2808799" href="#ftn.id2808799">6</a>]</sup></p><div class="footnotes"><br/><hr width="100" align="left"/><div class="footnote"><p><sup>[<a id="ftn.id2808745" href="#id2808745">5</a>] </sup>Yes, the Hamming of &#8216;Hamming distance&#8217;
and &#8216;Hamming code&#8217;.</p></div><div class="footnote"><p><sup>[<a id="ftn.id2808799" href="#id2808799">6</a>] </sup>Jim Gettys, one of the architects of X (and a
contributor to this book), has meditated in depth on how X's
laissez-faire style might be productively carried forward in
<i>The Two-Edged Sword</i> [<a href="apb.html#Gettys" title="[Gettys]">Gettys</a>].  This essay is well worth reading,
both for its specific proposals and for its expression of the Unix
mindset.</p></div></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="philosophychapter.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch01s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The Case against Learning Unix Culture </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> What Unix Gets Right</td></tr></table></div></body></html>
